#
# Test case for check behavior when network interface of two gfsd node is
# down in reading files
#
load	"calc_checksum" \
	"wait_for_gfsd_connect" \
	"generate_testdata"

#
# Test parameters
#
# GFARM_HOME:	A directory path of Gfarm which this test will be executed
# FILE_SIZE:	Size of a file to be created
# SLEEP_SEC:	Second to sleep before make network interface down
test_two_gfsd_ifdown_in_read()
{
	RESULT=$RESULT_PASS

	# default parameter
	GFARM_HOME=${GFARM_HOME-"/"}
	FILE_SIZE=${FILE_SIZE-"100M"}
	SLEEP_SEC=${SLEEP_SEC-"3"}
	RETRY_COUNT=${RETRY_COUNT-"20"}
	RETRY_INTERVAL=${RETRY_INTERVAL-"30"}

	# prepare: check whether required host is defined
	$GFSERVICE $DEBUG check_hostids_defined - "gfmd1 gfsd1 gfsd2 client1"
	[ $? -ne 0 ] && return $RESULT_UNSUPPORTED

	AUTH_TYPE=`$GFSERVICE $DEBUG get-config-gfarm-param gfmd1 AUTH_TYPE`
	if [ X$AUTH_TYPE = Xgsi ] || [ X$AUTH_TYPE = Xgsi_auth ]; then
		$GFSERVICE $DEBUG grid_proxy_init client1
	fi

	# prepare: wait until gfsd get connected
	wait_for_gfsd_connect gfsd1 client1 $RETRY_COUNT $RETRY_INTERVAL
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: gfsd1 is unavailable"
		return $RESULT_FATAL
	fi

	wait_for_gfsd_connect gfsd2 client1 $RETRY_COUNT $RETRY_INTERVAL
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: gfsd2 is unavailable"
		return $RESULT_FATAL
	fi

	# prepare: calc checksum
	CHECKSUM=`calc_checksum $FILE_SIZE`

	# prepare: mount
	MOUNT_POINT=mnt_$TEST_EXEC_ID
	$GFSERVICE $DEBUG exec_ssh client1 mkdir $MOUNT_POINT
	$GFSERVICE $DEBUG mount client1 $MOUNT_POINT -o modules=subdir \
		-o subdir=$GFARM_HOME

	# prepare: make file
	GFARM_FILE1=$GFARM_HOME/${TEST_EXEC_ID}_1
	generate_testdata $FILE_SIZE | $GFSERVICE $DEBUG read_and_register \
		client1 $GFARM_FILE1 gfmd1 gfsd1

	GFARM_FILE2=$GFARM_HOME/${TEST_EXEC_ID}_2
	generate_testdata $FILE_SIZE | $GFSERVICE $DEBUG read_and_register \
		client1 $GFARM_FILE2 gfmd1 gfsd2

	# step: read files in background
	FILE_PATH1=$MOUNT_POINT/${TEST_EXEC_ID}_1
	$GFSERVICE $DEBUG read_file client1 $FILE_PATH1 &
	READ_PID1=$!

	FILE_PATH2=$MOUNT_POINT/${TEST_EXEC_ID}_2
	$GFSERVICE $DEBUG read_file client1 $FILE_PATH2 &
	READ_PID2=$!

	# wait a bit for a process starts reading files
	sleep $SLEEP_SEC

	# step: make network interface down
	$GFSERVICE $DEBUG ifdown gfsd1
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: failed to execute ifdown on gfsd1"
		return $RESULT_FATAL
	fi

	$GFSERVICE $DEBUG ifdown gfsd2
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: failed to execute ifdown on gfsd2"
		return $RESULT_FATAL
	fi

	wait $READ_PID1
	if [ $? -eq 0 ]; then
		log_warn "$TESTNAME: unexpectedly suceeded to read a file" \
			"on gfsd1"
		set_result RESULT $RESULT_XPASS
	fi

	wait $READ_PID2
	if [ $? -eq 0 ]; then
		log_warn "$TESTNAME: unexpectedly suceeded to read a file" \
			"on gfsd2"
		set_result RESULT $RESULT_XPASS
	fi

	# step: make network interface up
	$GFSERVICE $DEBUG ifup gfsd1
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: failed to execute ifup on gfsd1"
		return $RESULT_FATAL
	fi

	$GFSERVICE $DEBUG ifup gfsd2
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: failed to execute ifup on gfsd2"
		return $RESULT_FATAL
	fi

	# step: wait until gfsd get connected
	wait_for_gfsd_connect gfsd1 client1 $RETRY_COUNT $RETRY_INTERVAL
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: gfsd1 is unavailable"
		return $RESULT_FATAL
	fi

	wait_for_gfsd_connect gfsd2 client1 $RETRY_COUNT $RETRY_INTERVAL
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: gfsd2 is unavailable"
		return $RESULT_FATAL
	fi

	# step: read files
	$GFSERVICE $DEBUG read_file client1 $FILE_PATH1 $CHECKSUM
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: failed to read files from gfsd1"
		set_result RESULT $RESULT_FAIL
	fi

	$GFSERVICE $DEBUG read_file client1 $FILE_PATH2 $CHECKSUM
	if [ $? -ne 0 ]; then
		log_warn "$TESTNAME: failed to read files from gfsd2"
		set_result RESULT $RESULT_FAIL
	fi

	# cleanup: remove files
	$GFSERVICE $DEBUG exec_ssh client1 rm -r $FILE_PATH

	# cleanup: unmount
	$GFSERVICE $DEBUG umount client1 $MOUNT_POINT
	$GFSERVICE $DEBUG exec_ssh client1 rmdir $MOUNT_POINT

	return $RESULT
}
